/**
 * Email itinerary PDF service.
 * Generates PDF locally with pdfkit, then calls n8n webhook to send via Gmail.
 */

import PDFDocument from 'pdfkit';
import { Itinerary, Constraints } from '@shared/types';

const N8N_WEBHOOK_URL = process.env.N8N_WEBHOOK_URL || 'https://skarailabs.app.n8n.cloud/webhook/send-itinerary';
const EMAIL_DRY_RUN = process.env.EMAIL_DRY_RUN === 'true';

// Generate unique request ID
function generateRequestId(): string {
  return `email_${Date.now().toString(36)}_${Math.random().toString(36).substring(2, 8)}`;
}

// Mask email for logging (show first 3 chars + domain)
function maskEmail(email: string): string {
  const [local, domain] = email.split('@');
  if (!domain) return '***';
  const masked = local.length > 3 ? local.substring(0, 3) + '***' : local;
  return `${masked}@${domain}`;
}

interface SendItineraryEmailParams {
  toEmail: string;
  sessionId: string;
  itinerary: Itinerary;
  constraints: Constraints;
  sources?: any;
}

interface EmailResult {
  ok: boolean;
  requestId: string;
  messageId?: string;
  sentTo?: string;
  error?: string;
  dryRun?: boolean;
  pdfSizeBytes?: number;
}

/**
 * Generate PDF buffer from itinerary
 */
async function generateItineraryPdf(
  itinerary: Itinerary,
  constraints: Constraints
): Promise<Buffer> {
  return new Promise((resolve, reject) => {
    const chunks: Buffer[] = [];
    const doc = new PDFDocument({ size: 'A4', margin: 50 });

    doc.on('data', (chunk) => chunks.push(chunk));
    doc.on('end', () => resolve(Buffer.concat(chunks)));
    doc.on('error', reject);

    const city = constraints.resolvedCity || constraints.city || 'Trip';
    const numDays = constraints.numDays || itinerary.days.length;
    const pace = constraints.pace || 'normal';

    // Title
    doc.fontSize(24).font('Helvetica-Bold').text(`${city} Itinerary`, { align: 'center' });
    doc.moveDown(0.5);
    doc.fontSize(14).font('Helvetica').text(`${numDays} Days • ${pace.charAt(0).toUpperCase() + pace.slice(1)} Pace`, { align: 'center' });
    doc.moveDown(1);

    // Trip summary
    doc.fontSize(10).fillColor('#666666');
    doc.text(`Generated by Voice-First Travel Planner`, { align: 'center' });
    doc.moveDown(2);

    // Days
    itinerary.days.forEach((day, dayIdx) => {
      doc.fillColor('#000000').fontSize(16).font('Helvetica-Bold');
      doc.text(day.name || `Day ${dayIdx + 1}`);
      doc.moveDown(0.5);

      day.blocks.forEach((block) => {
        doc.fontSize(12).font('Helvetica-Bold').fillColor('#333333');
        doc.text(`${block.timeOfDay}: ${block.title}`);
        
        doc.fontSize(10).font('Helvetica').fillColor('#666666');
        doc.text(`Duration: ${block.durationHours} hours`);
        
        if (block.travelFromPrev && block.travelFromPrev.minutes > 0) {
          doc.text(`Travel: ~${block.travelFromPrev.minutes} min by ${block.travelFromPrev.mode}`);
        }

        if (block.notes && block.notes.length > 0) {
          const cleanNotes = block.notes
            .map(n => n.replace(/\[(?:MAKE_MORE_RELAXED|SET_PACE|REDUCE_TRAVEL|SWAP_TO_INDOOR|ADD_FOOD_PLACE)\]/gi, '').trim())
            .filter(n => n);
          if (cleanNotes.length > 0) {
            doc.text(`Notes: ${cleanNotes.join('; ')}`);
          }
        }
        doc.moveDown(0.5);
      });

      doc.text(`Total: ${day.totalPlannedHours} hours planned`, { align: 'right' });
      doc.moveDown(1);

      // Page break after each day except last
      if (dayIdx < itinerary.days.length - 1) {
        doc.addPage();
      }
    });

    // Footer
    doc.moveDown(2);
    doc.fontSize(8).fillColor('#999999');
    doc.text(`Sources: OpenStreetMap, Wikivoyage`, { align: 'center' });
    doc.text(`Generated: ${new Date().toLocaleDateString()}`, { align: 'center' });

    doc.end();
  });
}

/**
 * Generate HTML email body
 */
function generateEmailBody(itinerary: Itinerary, constraints: Constraints): string {
  const city = constraints.resolvedCity || constraints.city || 'Trip';
  const numDays = constraints.numDays || itinerary.days.length;
  const pace = constraints.pace || 'normal';

  let daysSummary = itinerary.days.map((day, i) => {
    const highlights = day.blocks.map(b => b.title).join(', ');
    return `<li><strong>${day.name || `Day ${i + 1}`}:</strong> ${highlights}</li>`;
  }).join('\n');

  return `
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <style>
    body { font-family: Arial, sans-serif; line-height: 1.6; color: #333; }
    .header { background: #f8f9fa; padding: 20px; border-radius: 8px; margin-bottom: 20px; }
    .header h1 { margin: 0; color: #1a1a1a; }
    .header p { margin: 5px 0 0; color: #666; }
    ul { padding-left: 20px; }
    li { margin-bottom: 8px; }
    .footer { margin-top: 30px; padding-top: 20px; border-top: 1px solid #eee; color: #888; font-size: 12px; }
  </style>
</head>
<body>
  <div class="header">
    <h1>Your ${city} Itinerary</h1>
    <p>${numDays} Days • ${pace.charAt(0).toUpperCase() + pace.slice(1)} Pace</p>
  </div>
  
  <p>Here's your personalized travel itinerary! Please find the detailed PDF attached.</p>
  
  <h3>Trip Overview</h3>
  <ul>
    ${daysSummary}
  </ul>
  
  <p>The attached PDF contains your complete day-by-day itinerary with timing, travel estimates, and notes.</p>
  
  <div class="footer">
    <p>Generated by Voice-First Travel Planner<br>
    Sources: OpenStreetMap, Wikivoyage</p>
  </div>
</body>
</html>
  `.trim();
}

/**
 * Send itinerary PDF via n8n webhook.
 * Generates PDF locally, then calls n8n to send email via Gmail.
 */
export async function sendItineraryEmail(
  params: SendItineraryEmailParams
): Promise<EmailResult> {
  const requestId = generateRequestId();
  const maskedEmail = maskEmail(params.toEmail);
  const startTime = performance.now();

  console.log(`[EMAIL] START | requestId=${requestId} sessionId=${params.sessionId} toEmail=${maskedEmail}`);

  try {
    // Step 1: Generate PDF
    const pdfStart = performance.now();
    console.log(`[PDF] Generating PDF for ${params.constraints.resolvedCity || params.constraints.city}...`);
    
    const pdfBuffer = await generateItineraryPdf(params.itinerary, params.constraints);
    const pdfBase64 = pdfBuffer.toString('base64');
    const pdfSizeBytes = pdfBuffer.length;
    
    const pdfLatency = Math.round(performance.now() - pdfStart);
    console.log(`[PDF] Generated | size=${pdfSizeBytes} bytes | latency=${pdfLatency}ms`);

    // Step 2: Generate email content
    const city = params.constraints.resolvedCity || params.constraints.city || 'Trip';
    const subject = `Your ${city} Itinerary (PDF)`;
    const bodyHtml = generateEmailBody(params.itinerary, params.constraints);
    const filename = `${city.toLowerCase().replace(/\s+/g, '-')}-itinerary.pdf`;

    // Step 3: Check for dry run
    if (EMAIL_DRY_RUN) {
      const totalLatency = Math.round(performance.now() - startTime);
      console.log(`[EMAIL] DRY_RUN | requestId=${requestId} | pdfSizeBytes=${pdfSizeBytes} | totalLatency=${totalLatency}ms`);
      return {
        ok: true,
        requestId,
        dryRun: true,
        pdfSizeBytes,
      };
    }

    // Step 4: Call n8n webhook (with timeout)
    const n8nStart = performance.now();
    console.log(`[N8N] Calling webhook | url=${N8N_WEBHOOK_URL}`);

    const n8nPayload = {
      toEmail: params.toEmail,
      subject,
      bodyText: bodyHtml,
      filename,
      pdfBase64,
    };

    // 30 second timeout for webhook call
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), 30000);

    const response = await fetch(N8N_WEBHOOK_URL, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(n8nPayload),
      signal: controller.signal,
    });
    
    clearTimeout(timeoutId);

    const n8nLatency = Math.round(performance.now() - n8nStart);
    const totalLatency = Math.round(performance.now() - startTime);

    if (!response.ok) {
      const errorText = await response.text();
      console.error(`[N8N] HTTP ERROR | status=${response.status} | latency=${n8nLatency}ms | error=${errorText}`);
      return {
        ok: false,
        requestId,
        error: `n8n HTTP ${response.status}: ${response.statusText}`,
        pdfSizeBytes,
      };
    }

    const n8nResult = await response.json();
    console.log(`[N8N] Response | status=${response.status} | latency=${n8nLatency}ms | ok=${n8nResult.ok}`);

    if (!n8nResult.ok) {
      console.error(`[N8N] FAILED | error=${n8nResult.error}`);
      return {
        ok: false,
        requestId,
        error: n8nResult.error || 'n8n returned error',
        pdfSizeBytes,
      };
    }

    console.log(`[EMAIL] DONE | requestId=${requestId} | totalLatency=${totalLatency}ms | sentTo=${maskedEmail}`);

    return {
      ok: true,
      requestId,
      messageId: n8nResult.messageId,
      sentTo: params.toEmail,
      pdfSizeBytes,
    };

  } catch (error: any) {
    const totalLatency = Math.round(performance.now() - startTime);
    
    // Handle timeout separately for clearer error message
    const errorMessage = error.name === 'AbortError' 
      ? 'Email service timed out. Please try again.'
      : (error.message || 'Failed to send email');
    
    console.error(`[EMAIL] ERROR | requestId=${requestId} | latency=${totalLatency}ms | error=${errorMessage}`);
    
    return {
      ok: false,
      requestId,
      error: errorMessage,
    };
  }
}
